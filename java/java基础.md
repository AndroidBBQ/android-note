## 面向对象编程的四大特性及其含义？


> *   技术点：面向对象编程特点
> *   思路：分条简述每个特性的含义
> *   参考回答：
>     *   抽象：对现实世界的事物进行概括，抽象为在计算机虚拟世界中有意义的实体
>     *   封装：将某事物的属性和行为包装到对象中，构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，并且尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系
>     *   继承：子类继承父类，不仅可以有父类原有的方法和属性，也可以增加自己的或者重写父类的方法及属性
>     *   多态：允许不同类的对象对同一消息做出各自的响应

## String、StringBuffer和StringBuilder的区别？

> *   技术点：String
> *   参考回答：
>     *   String是字符串常量，而StringBuffer、StringBuilder都是字符串变量，即String对象一创建后不可更改，而后两者的对象是可更改的：
>     *   StringBuffer是线程安全的，而StringBuilder是非线程安全的，这是由于StringBuffer对方法加了同步锁或者对调用的方法加了同步锁
>     *   String更适用于少量的字符串操作的情况，StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况，StringBuffer适用于多线程下在字符缓冲区进行大量操作的情况

## Q：String a=""和String a=new String("")的的关系和异同？

> *   技术点：String
> *   参考回答：
>     *   通过String a=""直接赋值的方式得到的是一个字符串常量，存在于常量池；注意，相同内容的字符串在常量池中只有一个，即如果池已包含内容相等的字符串会返回池中的字符串，反之会将该字符串放入池中
>     *   通过new String("")创建的字符串不是常量是实例对象，会在堆内存开辟空间并存放数据，且每个实例对象都有自己的地址空间
> *   引申：对于用String a=""和String a=new String("")两种方式定义的字符串，判断使用equals()、"=="比较结果是什么

## Object的equal()和==的区别？

> *   技术点：equal()、==
> *   参考回答：
>     *   equals()：是Object的公有方法，具体含义取决于如何重写，比如String的equals()比较的是两个字符串的内容是否相同
>     *   "==" ：对于基本数据类型来说，比较的是两个变量值是够是否相等，对于引用类型来说，比较的是两个对象的内存地址是否相同
> *   引申：对于用String a=""和String a=new String("")两种方式定义的字符串，判断使用equals()、"=="比较结果是什么

## Q：装箱、拆箱什么含义？

> *   技术点：装箱、拆箱
> *   参考回答：装箱就是自动将基本数据类型转换为包装器类型，拆箱就是自动将包装器类型转换为基本数据类型

## Q：int和Integer的区别？

> *   技术点：基本数据类型、引用类型
> *   参考回答：
>     *   Integer是int的包装类，int则是java的一种基本数据类型
>     *   Integer变量必须实例化后才能使用，而int变量不需要
>     *   Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值
>     *   Integer的默认值是null，int的默认值是0

## Q：遇见过哪些运行时异常？异常处理机制知道哪些？

> *   技术点：Java异常机制
> *   思路：对Throwable异常进行分类说明每种异常的特点和常见问题，简述几种常见异常处理机制，详见[Java基础之异常机制](https://www.jianshu.com/p/3718766df5ba)
> *   参考回答：
> *   （1） Throwable继承层次结构，可见分成两大类Error和Exception：
>     *   Error（错误）:指程序**无法**恢复的异常情况，表示运行应用程序中较严重的问题；发生于虚拟机自身、或者在虚拟机试图执行应用时，如Virtual MachineError（Java虚拟机运行错误）、NoClassDefFoundError（类定义错误）；属于**不可查**异常，即不强制程序员必须处理，即使不处理也不会出现语法错误。
>     *   Exception（异常）:指程序**有可能**恢复的异常情况，表示程序本身可以处理的异常。又分两大类：
>         *   RuntimeException（运行时异常）：由程序**自身**的问题导致产生的异常；如NullPointerException（空指针异常）、IndexOutOfBoundsException（下标越界异常）；属于**不可查**异常。
>         *   非运行时异常：由程序**外部**的问题引起的异常；除了RuntimeException以外的异常，如FileNotFoundException（文件不存在异常）；属于**可查**异常，即强制程序员必须进行处理，如果不进行处理则会出现语法错误。
![](https://upload-images.jianshu.io/upload_images/5494434-f238ec7504cec330?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

> *   （2）常见的异常处理机制有：
>     *   捕捉异常：由系统自动抛出异常，即try捕获异常->catch处理异常->finally 最终处理
>     *   抛出异常：在方法中将异常对象**显性**地抛出，之后异常会沿着调用层次向上抛出，交由调用它的方法来处理。配合throws声明抛出的异常和throw抛出异常
>     *   自定义异常：继承Execption类或其子类

## Q：什么是反射，有什么作用和应用？`

> *   技术点：反射
> *   思路：简述反射的定义、功能和应用，详见[Java基础之泛型&反射](https://www.jianshu.com/p/fcdfb8234b66)
> *   参考回答：
>     *   **含义**：在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任何一个对象都能够调用它的任何一个方法和属性。
>     *   **功能**：动态性，体现在：在运行时判断任意一个类所具有的属性和方法； 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时调用任意一个对象的方法；生成动态代理
>     *   应用：反射&泛型
> *   引申：是否在项目中使用过反射机制，有什么优缺点

## 什么是内部类？有什么作用？静态内部类和非静态内部类的区别？`

> *   技术点：内部类
> *   思路：
> *   参考回答：内部类就是定义在另外一个类里面的类。它隐藏在外部类中，封装性更强，不允许除外部类外的其他类访问它；但它可直接访问外部类的成员。静态内部类和非静态内部类的区别有：
>     *   静态内部类是指被声明为static的内部类，可不依赖外部类实例化；而非静态内部类需要通过生成外部类来间接生成。
>     *   静态内部类只能访问外部类的静态成员变量和静态方法，而非静态内部类由于持有对外部类的引用，可以访问外部类的所用成员
> *   引申：谈谈匿名内部类

## final、finally、finalize()分别表示什么含义`

> *   技术点：final、finally、finalize()
> *   参考回答：
>     *   final关键字表示不可更改，具体体现在：
>         *   final修饰的变量必须要初始化，且赋初值后不能再重新赋值
>         *   final修饰的方法不能被子类重写
>         *   final修饰的类不能被继承
>     *   finally：和try、catch成套使用进行异常处理，无论是否捕获或处理异常，finally块里的语句都会被执行，在以下4种特殊情况下，finally块才不会被执行：
>         *   在finally语句块中发生了异常
>         *   在前面的代码中用了`System.exit()`退出程序
>         *   程序所在的线程死亡
>         *   关闭CPU
>     *   finalize()：是Object中的方法，当垃圾回收器将回收对象从内存中清除出去之前会调用finalize()，但此时并不代表该回收对象一定会“死亡”，还有机会“逃脱”

## 重写和重载的区别？`

> *   技术点：重写、重载
> *   参考回答：重写表示子类重写父类的方法；重载表示有多个同名函数同时存在，区别在于有不同的参数个数或类型
> *   引申：谈谈动态分派和静态分派

## 抽象类和接口的异同？

> *   技术点：抽象类、接口
> *   参考回答：
>     *   使用上的区别：一个类只能继承一个抽象类却可以实现多个接口
>     *   设计上的区别：接口是对行为的抽象，无需有子类的前提，是自上而下的设计理念；抽象类是对类的抽象，建立于相似子类之上，是自下而上的设计理念

## 为什么匿名内部类中使用局部变量要用final修饰？`

> *   技术点：匿名内部类
> *   参考回答：一方面，由于方法中的局部变量的生命周期很短，一旦方法结束变量就要被销毁，为了保证在内部类中能找到外部局部变量，通过final关键字可得到一个外部变量的引用；另一方面，通过final关键字也不会在内部类去做修改该变量的值，保护了数据的一致性。

## Q：Object有哪些公有方法？

> *   技术点：Object
> *   思路：列举常见的几个公有方法
> *   参考回答：
>     *   equals()： 和==作用相似
>     *   hashCode()：用于哈希查找，重写了equals()一般都要重写该方法
>     *   getClass()： 获取Class对象
>     *   wait()：让当前线程进入等待状态，并释放它所持有的锁
>     *   notify()&notifyAll()： 唤醒一个（所有）正处于等待状态的线程
>     *   toString()：转换成字符串
> *   引申：equals()和==的不同、在synchronized 同步代码块里wait()和notify()&notifyAll()如何配合、hashCode()和equals()的关系、获取Class对象还有什么方法

*   [集合](https://www.jianshu.com/p/7b9abda70c8f)

## Q：Java集合框架中有哪些类？都有什么特点

> *   技术点：集合框架
> *   思路：分条解释每种类的特点
> *   参考回答：可将Java集合框架大致可分为Set、List、Queue 和Map四种体系
>     *   Set：代表**无序、不可重复**的集合，常见的类如HashSet、TreeSet
>     *   List：代表**有序、可重复**的集合，常见的类如动态数组ArrayList、双向链表LinkedList、可变数组Vector
>     *   Map：代表具有**映射关系**的集合，常见的类如HashMap、LinkedHashMap、TreeMap
>     *   Queue：代表一种**队列**集合

## Q：集合、数组、泛型的关系，并比较

> *   技术点：集合、数组、泛型
> *   参考回答：
> *   （1）集合和数组的区别：
>     *   数组元素可以是基本类型，也可以是对象；数组长度限定；数组只能存储一种类型的数据元素
>     *   集合元素只能是对象；集合长度可变；集合可存储不同种的数据元素
> *   （2）泛型相比与集合的好处在于它**安全简单**。具体体现在提供编译时的强类型检查，而不用等到运行；可避免类类型强制转换

## Q：ArrayList和LinkList的区别？

> *   技术点：List对比
> *   参考回答：
>     *   **ArrayList**的底层结构是**数组**，可用索引实现快速查找；是动态数组，相比于数组容量可实现动态增长
>     *   **LinkedList**底层结构是**链表**，增删速度快；是一个**双向循环**链表，也可以被当作堆栈、队列或双端队列

## Q：ArrayList和Vector的区别？

> *   技术点：List对比
> *   参考回答：
>     *   **ArrayList**非线程安全，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList；默认初始容量为10，每次扩容为原来的1.5倍
>     *   **Vector**使用了synchronized关键字，是**线程安全**的，比ArrayList开销更大，访问更慢；默认初始容量为10，默认每次扩容为原来的2倍，可通过**capacityIncrement**属性设置

## Q：HashSet和TreeSet的区别？

> *   技术点：Set对比
> *   参考回答：
>     *   **HashSet**不能保证元素的排列顺序；使用**Hash算法**来存储集合中的元素，有良好的存取和查找性能；通过`equal()`判断两个元素是否相等，并两个元素的`hashCode()`返回值也相等
>     *   **TreeSet**是SortedSet接口的实现类，根据元素**实际值的大小**进行排序；采用**红黑树**的数据结构来存储集合元素；支持两种排序方法：**自然排序**（默认情况）和**定制排序**。前者通过实现**Comparable接口**中的`compareTo()`比较两个元素之间大小关系，然后按升序排列；后者通过实现**Comparator接口**中的`compare()`比较两个元素之间大小关系，实现定制排列

## Q：HashMap和Hashtable的区别？

> *   技术点：Map对比
> *   参考回答：
>     *   **HashMap**基于AbstractMap类，实现了Map、**Cloneable**（能被克隆）、**Serializable**（支持序列化）接口； **非线程安全**；允许存在一个为null的key和任意个为null的value；采用**链表散列**的数据结构，即数组和链表的结合；初始容量为16，填充因子默认为0.75，扩容时是当前容量翻倍，即2capacity
>     *   **Hashtable**基于Map接口和Dictionary类；**线程安全**，开销比HashMap大，如果多线程访问一个Map对象，使用Hashtable更好；不允许使用null作为key和value；底层基于哈希表结构；初始容量为11，填充因子默认为0.75，扩容时是容量翻倍+1，即2capacity+1

## Q：HashMap在put、get元素的过程？体现了什么数据结构？

> *   技术点：HashMap
> *   参考回答：
>     *   向Hashmap中put元素时，首先判断key是否为空，为空则直接调用putForNullKey()，不为空则计算key的hash值得到该元素在数组中的下标值；如果数组在该位置处没有元素，就直接保存；如果有，还要比较是否存在相同的key，存在的话就覆盖原来key的value，否则将该元素保存在链头，先保存的在链尾。
>     *   从Hashmap中get元素时，计算key的hash值找到在数组中的对应的下标值，返回该key对应的value即可，如果有冲突就遍历该位置链表寻找key相同的元素并返回对应的value
>     *   由此可看出HashMap采用**链表散列**的数据结构，即数组和链表的结合，在Java8后又结合了红黑树，当链表元素超过8个将链表转换为红黑树

## 如何解决Hash冲突？

> *   技术点：Hash冲突
> *   参考回答：
>     *   开放定址法：常见的线性探测方式，在冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表
>     *   链地址法：将有冲突数组位置生出链表
>     *   建立公共溢出区：将哈希表分为基本表和溢出表两部分，和基本表发生冲突的元素一律填入溢出表
>     *   再哈希法：构造多个不同的哈希函数，有冲突使用下一个哈希函数计算hash值

## Q：如何保证HashMap线程安全？什么原理？

> *   技术点：ConcurrentHashMap
> *   思路：这里回答一种办法，使用ConcurrentHashMap
> *   参考回答：ConcurrentHashMap是线程安全的HashMap，它采取锁分段技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。在JDK1.8中对ConcurrentHashmap做了两个改进：
>     *   取消segments字段，直接采用`transient volatile HashEntry<K,V>[] table`保存数据，将数组元素作为锁，对每一行数据进行加锁，可减少并发冲突的概率
>     *   数据结构由“数组＋单向链表”变为“数组＋单向链表＋红黑树”，使得查询的时间复杂度可以降低到O(logN)，改进一定的性能。
> *   引申：LinkHashMap线程安全的底层实现

## Q：HashMap是有序的吗？如何实现有序？`

> *   技术点：LinkHashMap
> *   思路：这里回答一种办法，使用LinkedHashMap
> *   参考回答：HashMap是无序的，而LinkedHashMap是有序的HashMap，默认为插入顺序，还可以是访问顺序，基本原理是其内部通过Entry维护了一个双向链表，负责维护Map的迭代顺序
> *   引申：LinkHashMap有序的底层实现

## HashMap是如何扩容的？如何避免扩容？`

> *   技术点：HashMap
> *   参考回答：
>     *   HashMap几个默认值，初始容量为16、填充因子默认为0.75、扩容时容量翻倍。也就是说当HashMap中元素个数超过`16*0.75=12`时会把数组的大小扩展为`2*16=32`，然后重新计算每个元素在数组中的位置
>     *   由于每次扩容还需要重新计算元素Hash值，损耗性能，所以建议在使用HashMap时，最好先估算Map的大小，设置初始值，避免频繁扩容

## Q：hashcode()的作用，与equal()有什么区别？`

> *   技术点：Hash值
> *   参考回答：hashCode()用于计算对象的Hash值，确认对象在散列存储结构中的存储地址。和equal()的区别：
>     *   equals()比较两个对象的地址值是否相等 ；hashCode()得到的是对象的存储位置，可能不同对象会得到相同值
>     *   有两个对象，若equals()相等，则hashcode()一定相等；hashcode()不等，则equals()一定不相等；hashcode()相等，equals()可能相等、可能不等
>     *   使用equals()比较两个对象是否相等效率较低，最快办法是先用hashCode()比较，如果hashCode()不相等，则这两个对象肯定不相等；如果hashCode()相等，此时再用equal()比较，如果equal()也相等，则这两个对象的确相等，反之