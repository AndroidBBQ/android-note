# 五层模型
一般分为七层模型或五层模型，这里只记住五层模型就行。
![](https://raw.githubusercontent.com/xioabaiwenwen/upload-images/master/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20190127172859.png)
要记住各层的协议：

* 物理层 

该层负责比特流的传输，主要是物理层的传输，和协议没有什么关系，和传输介质有关。

* 数据链路层

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议，数据链路层将网络层交下来IP数据报组装成数据帧，在两个相邻节点间的链路上传送帧；数据帧：（所谓数据帧（Data frame），就是数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。

* 网络层

网络层的主要功能是寻址和对数据报的封装以及重要的路由选择功能。 这些功能大部分都是由IP协议来完成的，再加上地址解析协议（Address Resolution Protocol，ARP）、因特网控制报文协议（Internet Control Message Protocol，ICMP）等协议从旁协助，所以IP协议是本层众多实体中的核心。

* 数据链路层

向两个主机中应用进程之间的通信提供通用的数据传输服务。应用进程以利用该服务传送应用层报文。该层主要有TCP，UDP协议。

* 应用层

为操作系统或网络应用程序提供访问网络服务的接口；通过应用进程间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互规则。不同的网络应用层有不同的应用层协议，如：万维网应用的HTTP协议，电子邮件的SMTP协议，支持文件传送的FTP协议，应用层交互的数据单元称为报文。

# 协议
## http协议
> HTTP 0.9：1991年发布的第一个版本，只有一个命令GET，服务器只能回应HTML格式的字符串。
> HTTP 1.0：1996年发布的版本，内容量大大增加。除了GET命令外，还引入了POST命令和HEAD命令，HTTP请求和回应的格式除了数据部分，每次通信都必须包括头信息，用来描述一些元数据。
> HTTP 1.1：1997发布的版本，进一步完善了HTTP协议，直到现在还是最流行的版本。
> SPDY协议：2009年谷歌为了解决 HTTP 1.1效率不高的问题而自行研发的协议。
> HTTP 2：2015年新发布的版本，SPDY 协议的主要特性也在此版本中。

## http版本之间的区别
> 1.1相对于1.0：
* 支持长连接
* 增加了host域
* 增加了range头域，支持断点续传


> 2.0和1.X的区别:
* 支持多路复用
* 采用二进制分帧
* 首部压缩
* 服务器推送

## http的特点：
* 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
* 灵活：HTTP允许传输任意类型的数据对象。
* 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力。

## https协议
>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

>能保证安全的原理就是利用了非对称加密算法，平常用的对称加密算法之所以不安全，是因为双方是用统一的密匙进行加密解密的，只要双方任意一方泄漏了密匙，那么其他人就可以利用密匙解密数据。
>
而非对称加密算法之所以能实现安全传输的核心精华就是：公钥加密的信息只能用私钥解开，私钥加密的信息只能被公钥解开。

>简单过程：
服务端申请CA机构颁发的证书，则获取到了证书的公钥和私钥，私钥只有服务器端自己知道，而公钥可以告知其他人，如可以把公钥传给客户端，这样客户端通过服务端传来的公钥来加密自己传输的数据，而服务端利用私钥就可以解密这个数据了。由于客户端这个用公钥加密的数据只有私钥能解密，而这个私钥只有服务端有，所以数据传输就安全了。

## https协议和http协议的区别
1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## https协议请求过程
![](https://images2017.cnblogs.com/blog/1260476/201711/1260476-20171116160813812-635766483.png)


    在使用HTTPS是需要保证服务端配置正确了对应的安全证书

    客户端发送请求到服务端

    服务端返回公钥和证书到客户端

    客户端接收后会验证证书的安全性,如果通过则会随机生成一个随机数,用公钥对其加密,发送到服务端

    服务端接受到这个加密后的随机数后会用私钥对其解密得到真正的随机数,随后用这个随机数当做私钥对需要发送的数据进行对称加密

    客户端在接收到加密后的数据使用私钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户

    SSL加密建立

## http的请求报文
![](https://raw.githubusercontent.com/xioabaiwenwen/upload-images/master/20190128005849.png)

http的请求报文是由请求行，请求报头，空行，请求数据构成的。下面来一一进行讲解。
### 请求行
请求行是由请求方法，url，版本构成。

#### 请求方法
HTTP请求方法有8种，分别是GET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、
OPTIONS。对于移动开发最常用的就是GET和POST了。
* GET：请求获取Request-URI所标识的资源。
* POST：在Request-URI所标识的资源后附加新的数据。
* HEAD：请求获取由Request-URI所标识的资源的响应消息报头。
* PUT：请求服务器存储一个资源，并用Request-URI作为其标识。
* DELETE：请求服务器删除Request-URI所标识的资源。
* TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断。
* CONNECT：HTTP 1.1协议中预留给能够将连接改为管道方式的代理服务器。
* OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求。

## 状态码
1xx：表示服务器已接收了客户端请求，客户端可继续发送请求 
2xx：表示服务器已成功接收到请求并进行处理 
200 OK：表示客户端请求成功 
3xx：表示服务器要求客户端重定向 
4xx：表示客户端的请求有非法内容 
400 Bad Request：表示客户端请求有语法错误，不能被服务器所理解 
401 Unauthonzed：表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 
403 Forbidden：表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 
404 Not Found：请求的资源不存在，例如，输入了错误的URL 
5xx：表示服务器未能正常处理客户端的请求而出现意外错误 
500 Internal Server Error：表示服务器发生不可预期的错误，导致无法完成客户端的请求 
503 Service Unavailable：表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 

## TCP和UDP的区别？

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等），并且UDP速度更快
4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道


## 三次握手和四次挥手

###图：

![](https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067)

### 三次握手：
第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；

第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

### 四次挥手：
第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；

第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。


### 为什么要三次握手
>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。

在谢希仁著《计算机网络》书中同时举了一个例子，如下：

>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

### 为什么要四次分手
>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。

>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）
FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）
CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）
LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）
TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）
CLOSED: 表示连接中断。

## HTTP和Socket的区别？
>HTTP是应用层协议；基于TCP协议；使用“请求—响应”方式建立连接，在请求时需要先建立连接且客户端要先发出请求，可见服务器需要等到客户端发送一次请求后才能将数据传回给客户端 
>
Socket（套接字）是对TCP/IP协议的封装，是接口而不是协议；创建Socket连接时可以指定传输层协议TCP或UDP；Socket建立连接过程三步骤：服务器监听->客户端请求->连接确认，可见服务器可以直接将数据传送给客户端（HTTP2.0也增加了服务端推送的功能）

## 在地址栏打入URL会发生什么？`

在浏览器地址栏键入URL，按下回车之后会经历以下流程： 
1. 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址 
2. 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接 
3. 浏览器发出读取文件的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器 
4. 服务器对浏览器请求作出响应，并把对应的html文本发送给浏览器 
5. 释放TCP连接，若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求 
6. 客户端将服务器响应的html文本解析并显示 

## websocket连接过程
1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。
2. TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）
3. 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。
4. 当收到了连接成功的消息后，通过TCP通道进行传输通信。 

## WebSocket与HTTP的关系 
相同点：
>都是一样基于TCP的，都是可靠性传输协议。
都是应用层协议。 

不同点：
> WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。
WebSocket是需要握手进行建立连接的。











