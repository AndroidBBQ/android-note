# 谈谈你对Context的认识
我们知道Android程序和java程序最大的区别就在于，在java中，你只需要一个main函数作为入口就可以跑起来了，Android程序是需要 一个完整的工程环境的，并且Activity、Service、Broadcast等系统组件并不是像普通的java对象一样随便new一下就能创建实例 的，而是需要各自的运行环境上下文，即这里的Context,可以这么讲，Context是维持Android程序中个组件能够正常工作的核心功能类，包 含了应用程序的环境信息，通过他我们可以获得应用程序的资源和类，Context的继承结构图是这样的：
![](https://raw.githubusercontent.com/xioabaiwenwen/upload-images/master/20190319235957.png)
 Context是抽象类，有两个类直接继承自他：ContextWrapper以及ContextImpl, 从名字上可以看出ContextWrapper是上下文功能的封装类，而ContextImpl是上下文功能的实现类，也就是说关于Context内方法 的真正实现都是在ContextImpl里面了，而ContextWrapper又有三个实现类，Application/Service /ContextThremeWrapper，而我们常见的Activity又是ContextThemeWrapper的子类，也就是 Application/Service/Activity都是ContextWrapper的子类了；一个应用程序中Context的数量 = Application的数量+Service的数量+Activity的数量，又因为一个应用程序中Application只有一个，所以实际上应用程 序中Context的数量 = Service的数量+Activity的数量+1；
     getApplication()和getApplicationContext()区别
        通常我们可以在Activity或者Service中通过getApplication()获得Application实例，但是在 BroadcastReceiver中却不行，原因在于getApplication方法是Activity和Service自己添加的，并不是 Context中本身就有的，如果我们想在BroadcastReceiber中获得Application实例的话，可以通过 getApplicationContext方法，也就是说getApplication的适用范围不如getApplicationContext；  
        使用Application的时候需要注意的是，它本身已经是全局唯一的了，这点是由系统来保证的，如果我们想要自己实现一个类似于单例模式的 Application类，不仅没必要，而且经常会出错，原因在于你写单例的时候通常是将构造函数写成private类型，并且对外提供一个public 方法来获得这个实例，而实例的获得是通过new的方式实现的，前面已经说过Android中并不能随便new一个上下文对象的子类就能抛弃程序来，他是需 要Android环境支撑的，你只是new了一个实例出来，但这个实例其实是跟Android没什么关系的，而系统在创建Application的时候是 会有当前环境信息的，这点需要注意一下； 
