# 前言
关于Android的四大组件可以说是烂大街了，记录本文的目的是在理解了的基础上简要的记录下常见的点，这些点必须要记住。

# Activity
## 官方图：
![](https://upload-images.jianshu.io/upload_images/682504-1405607172778d9b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/545)

## 一些状态：
* onCreate()表示Activity 正在创建，常做初始化工作，如setContentView界面资源、初始化数据
* onStart()表示Activity 正在启动，这时Activity 可见但不在前台，无法和用户交互
* onResume()表示Activity 获得焦点，此时Activity 可见且在前台并开始活动
* onPause()表示Activity 正在停止，可做 数据存储、停止动画等操作
* onStop()表示activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等
* onDestroy()表示Activity 即将销毁，常做回收工作、资源释放

## 一些操作的生命周期：
* 启动Activity: onCreate()-> onStart() -> onResume()
* 当A Activity跳转到新的B Activity或弹出一个对话框B时：A的 onPause() -> B的 onCreate() -> B的 onStart() -> B的 onResume 这是如果B是Activity并且可见，则调用 A的 onStop() ，如果B是Activity并且不可见，则不调用 A的 onStop()
* 如果用户按了back键：onPause() -> onStop() -> onDestroy()
* 如果用户按了home键：onPause() -> onStop() 如果被杀死则会调用onDestory()
* 重新进入activity：如果没有被杀死则 onRestart() -> onStart() -> onResume()  如果被杀死则： onCreate()-> onStart() -> onResume()

## onSaveInstanceState和onRestoreInstanceState：
> 当非人为终止Activity时，比如系统配置发生改变时导致Activity被杀死并重新创建、资源内存不足导致低优先级的Activity被杀死，会调用 onSavaInstanceState() 来保存状态。该方法调用在onStop之前，但和onPause没有时序关系。
>
>  当activity重新创建后，系统会调用onRestoreInstanceState，并且把activity销毁时onSaveInstanceState方法保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法。onRestoreInstanceState()onStart()方法后回调。

## 防止重新创建activity
ctivity指定configChange属性来不让系统重新创建activity。
```
android : configChanges = "orientation"
```
## 四种启动模式：
* standard标准模式：每次启动一个Activity就会创建一个新的实例
* singleTop栈顶复用模式：如果新Activity已经位于任务栈的栈顶，就不会重新创建，并回调 onNewIntent(intent) 方法，这个Activity它的onCreate()，onStart()方法不会被调用，因为它并没有发生改变。如果栈顶不存在该Activity的实例，则情况与standard模式相同。
* singleTask栈内复用模式：只要该Activity在一个任务栈中存在，都不会重新创建，并回调 onNewIntent(intent) 方法，同样这个Activity它的onCreate()，onStart()方法不会被调用，因为它并没有发生改变。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，并把该Activity放进去；如果存在，就会创建到已经存在的栈中。
* singleInstance单实例模式：具有此模式的Activity只能单独位于一个任务栈中，且此任务栈中只有唯一一个实例。

## 启动模式中的栈的判断方式：
在activity的清单配置中有一个taskAffinity属性：
```java
android:name=".ActivitySingleTop" android:launchMode="singleTop" android:taskAffinity="com.castiel.demo.singletop"/>
```
这个参数标识了一个Activity所需任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名，我们可以单独指定每一个Activity的taskAffinity属性覆盖默认值。上面启动模式中的栈的比较是通过这个属性来进行比较的。

很重要的一点taskAffinity属性不对standard和singleTop模式有任何影响，即时你指定了该属性为其他不同的值，这两种启动模式下不会创建新的task（如果不指定即默认值，即包名）。

对于singleTask模式：存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。

对于singleInstance模式，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。

## 启动模式的运用实例
* singleTop:适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。
* SingleTask模式：保持我们应用开启后仅仅有一个Activity的实例。最典型的样例就是应用中展示的主页（Home页）。
* singleInstance模式:需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。

# Service
## 官方图

## 两种启动Service的方式及其生命周期







